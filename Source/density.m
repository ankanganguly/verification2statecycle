%Calculate the density of a contact process path wrt reference path
%Inputs:
%    X: cell containing four objects
%        t: time at end of recorded process
%        init: initial value of process
%        jumps: 3xjump array. 1: jumptimes 2: jumpvertices 3:jump values
%        currVal: value of process at time t
%    lambda: infection rate
%Outputs:
%    d: the radon-nikodym derivative

%I should be able to simplify this a lot! But for now I won't.
function d = density(X,lambda)
    %Unpack X
    init = X{2};
    jumps = X{3};

    %Keep track of the number of nodes
    nodes = size(init,1);
    

    
    %Set the state trackers
    currState = init;
    cxcurrState = cInit;
    
    
    %Current state
    currState = init;
    curRate1 = sRate(currState, lambda{1});
    curRate2 = rRate({0,init,[],[]},lambda);
    
    %Compute everything directly if there are no jumps
    if size(jumpTimes,1) == 0
        d = exp(-(sum(curRate1 - curRate2,1)*t));
        dq = exp(-(sum(curRate1([1,2,3,end]) - curRate2([1,2,3,end]),1)*t));
        if abs(d - dq) > 0.001
            error('Bad computation');
        end
    end
        return
    end
    
    %product of density at each jump
    logProdStuff = zeros(size(jumpTimes,1),1);
    
    %Short hack to make intStuff work.
    jumpTimes = [jumpTimes;t];
    
    %integrate over partition generated by jumps
    intStuff = zeros(size(jumpTimes,1),1);
    
    %Do first integral manually
    intStuff(1) = jumpTimes(1)*(sum(curRate,1)-nodes);
    
    %Iterate over jumpNodes since it is the same size as original jumpTimes
    for i = 1:size(jumpNodes,1)
        
        %fix jump time difference and new node
        ti = jumpTimes(i+1) - jumpTimes(i);     %for integral
        nv = jumpNodes(i);                      %for log product
        
        %Compute log product stuff
        logProdStuff(i) = log(curRate(nv));
        
        %compute updated state and rate
        currState(nv) = mod(currState(nv) + 1,2);
        curRate = sRate(currState,lambda);
        
        %Compute the integral
        intStuff(i+1) = ti*(sum(curRate,1) - nodes);
    end
    
    logprod = sum(logProdStuff,1);
    int = sum(intStuff,1);
    
    d = exp(logprod - int);
    end

%Calculate the log of the sum of numbers given their logs
%Inputs:
%   a: log of first expression in sum
%   b: log of second expression in sum
%Outputs
%   s: log of sum
function s = ladd(a,b)
    s = log(exp(a - b) - 1) + b;
end