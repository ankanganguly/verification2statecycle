%Calculate the density of a contact process path wrt reference path
%Inputs:
%   X: cell containing four objects
%       t: time at end of recorded process
%       init: initial value of process
%       jumpTimes: times of jumps of process
%       jumpNodes: Nodes which jump at a given time
%   lambda: {infection rate, cX}
%       cX: cell containing 4 objects (fixed path on 1,2)
%       	t: time at end of recorded process
%       	init: initial value of process
%           jumpTimes: times of jumps of process
%           jumpNodes: Nodes which jump at a given time
%Outputs:
%   d: the radon-nikodym derivative

%I should be able to simplify this a lot! But for now I won't.
function d = density(X,lambda)
    %Unpack X
    t = X{1};
    init = X{2};
    jumpTimes = X{3};
    jumpNodes = X{4};
    
    %Unpack lambda
    lamb = lambda{1};
    cX = lambda{2};
    
    %Unpack cX
    ct = cX{1};
    cInit = cX{2};
    cJumpTimes = cX{3};
    cJumpNodes = cX{4};
    
    %Keep track of the number of nodes
    nodes = size(init,1);
    
    %Current state
    currState = init;
    curRate1 = sRate(currState, lambda{1});
    curRate2 = rRate({0,init,[],[]},lambda);
    
    %Compute everything directly if there are no jumps
    if size(jumpTimes,1) == 0
        d = exp(-(sum(curRate1 - curRate2,1)*t));
        dq = exp(-(sum(curRate1([1,2,3,end]) - curRate2([1,2,3,end]),1)*t));
        if abs(d - dq) > 0.001
            error('Bad computation');
        end
    end
        return
    end
    
    %product of density at each jump
    logProdStuff = zeros(size(jumpTimes,1),1);
    
    %Short hack to make intStuff work.
    jumpTimes = [jumpTimes;t];
    
    %integrate over partition generated by jumps
    intStuff = zeros(size(jumpTimes,1),1);
    
    %Do first integral manually
    intStuff(1) = jumpTimes(1)*(sum(curRate,1)-nodes);
    
    %Iterate over jumpNodes since it is the same size as original jumpTimes
    for i = 1:size(jumpNodes,1)
        
        %fix jump time difference and new node
        ti = jumpTimes(i+1) - jumpTimes(i);     %for integral
        nv = jumpNodes(i);                      %for log product
        
        %Compute log product stuff
        logProdStuff(i) = log(curRate(nv));
        
        %compute updated state and rate
        currState(nv) = mod(currState(nv) + 1,2);
        curRate = sRate(currState,lambda);
        
        %Compute the integral
        intStuff(i+1) = ti*(sum(curRate,1) - nodes);
    end
    
    logprod = sum(logProdStuff,1);
    int = sum(intStuff,1);
    
    d = exp(logprod - int);
end